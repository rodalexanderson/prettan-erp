{"ast":null,"code":"let {\n  list\n} = require('postcss');\n\nlet parser = require('postcss-value-parser');\n\nlet Browsers = require('./browsers');\n\nlet vendor = require('./vendor');\n\nclass Transition {\n  constructor(prefixes) {\n    this.props = ['transition', 'transition-property'];\n    this.prefixes = prefixes;\n  }\n  /**\n   * Process transition and add prefixes for all necessary properties\n   */\n\n\n  add(decl, result) {\n    let prefix, prop;\n    let add = this.prefixes.add[decl.prop];\n    let vendorPrefixes = this.ruleVendorPrefixes(decl);\n    let declPrefixes = vendorPrefixes || add && add.prefixes || [];\n    let params = this.parse(decl.value);\n    let names = params.map(i => this.findProp(i));\n    let added = [];\n\n    if (names.some(i => i[0] === '-')) {\n      return;\n    }\n\n    for (let param of params) {\n      prop = this.findProp(param);\n      if (prop[0] === '-') continue;\n      let prefixer = this.prefixes.add[prop];\n      if (!prefixer || !prefixer.prefixes) continue;\n\n      for (prefix of prefixer.prefixes) {\n        if (vendorPrefixes && !vendorPrefixes.some(p => prefix.includes(p))) {\n          continue;\n        }\n\n        let prefixed = this.prefixes.prefixed(prop, prefix);\n\n        if (prefixed !== '-ms-transform' && !names.includes(prefixed)) {\n          if (!this.disabled(prop, prefix)) {\n            added.push(this.clone(prop, prefixed, param));\n          }\n        }\n      }\n    }\n\n    params = params.concat(added);\n    let value = this.stringify(params);\n    let webkitClean = this.stringify(this.cleanFromUnprefixed(params, '-webkit-'));\n\n    if (declPrefixes.includes('-webkit-')) {\n      this.cloneBefore(decl, `-webkit-${decl.prop}`, webkitClean);\n    }\n\n    this.cloneBefore(decl, decl.prop, webkitClean);\n\n    if (declPrefixes.includes('-o-')) {\n      let operaClean = this.stringify(this.cleanFromUnprefixed(params, '-o-'));\n      this.cloneBefore(decl, `-o-${decl.prop}`, operaClean);\n    }\n\n    for (prefix of declPrefixes) {\n      if (prefix !== '-webkit-' && prefix !== '-o-') {\n        let prefixValue = this.stringify(this.cleanOtherPrefixes(params, prefix));\n        this.cloneBefore(decl, prefix + decl.prop, prefixValue);\n      }\n    }\n\n    if (value !== decl.value && !this.already(decl, decl.prop, value)) {\n      this.checkForWarning(result, decl);\n      decl.cloneBefore();\n      decl.value = value;\n    }\n  }\n  /**\n   * Find property name\n   */\n\n\n  findProp(param) {\n    let prop = param[0].value;\n\n    if (/^\\d/.test(prop)) {\n      for (let [i, token] of param.entries()) {\n        if (i !== 0 && token.type === 'word') {\n          return token.value;\n        }\n      }\n    }\n\n    return prop;\n  }\n  /**\n   * Does we already have this declaration\n   */\n\n\n  already(decl, prop, value) {\n    return decl.parent.some(i => i.prop === prop && i.value === value);\n  }\n  /**\n   * Add declaration if it is not exist\n   */\n\n\n  cloneBefore(decl, prop, value) {\n    if (!this.already(decl, prop, value)) {\n      decl.cloneBefore({\n        prop,\n        value\n      });\n    }\n  }\n  /**\n   * Show transition-property warning\n   */\n\n\n  checkForWarning(result, decl) {\n    if (decl.prop !== 'transition-property') {\n      return;\n    }\n\n    let isPrefixed = false;\n    let hasAssociatedProp = false;\n    decl.parent.each(i => {\n      if (i.type !== 'decl') {\n        return undefined;\n      }\n\n      if (i.prop.indexOf('transition-') !== 0) {\n        return undefined;\n      }\n\n      let values = list.comma(i.value); // check if current Rule's transition-property comma separated value list needs prefixes\n\n      if (i.prop === 'transition-property') {\n        values.forEach(value => {\n          let lookup = this.prefixes.add[value];\n\n          if (lookup && lookup.prefixes && lookup.prefixes.length > 0) {\n            isPrefixed = true;\n          }\n        });\n        return undefined;\n      } // check if another transition-* prop in current Rule has comma separated value list\n\n\n      hasAssociatedProp = hasAssociatedProp || values.length > 1;\n      return false;\n    });\n\n    if (isPrefixed && hasAssociatedProp) {\n      decl.warn(result, 'Replace transition-property to transition, ' + 'because Autoprefixer could not support ' + 'any cases of transition-property ' + 'and other transition-*');\n    }\n  }\n  /**\n   * Process transition and remove all unnecessary properties\n   */\n\n\n  remove(decl) {\n    let params = this.parse(decl.value);\n    params = params.filter(i => {\n      let prop = this.prefixes.remove[this.findProp(i)];\n      return !prop || !prop.remove;\n    });\n    let value = this.stringify(params);\n\n    if (decl.value === value) {\n      return;\n    }\n\n    if (params.length === 0) {\n      decl.remove();\n      return;\n    }\n\n    let double = decl.parent.some(i => {\n      return i.prop === decl.prop && i.value === value;\n    });\n    let smaller = decl.parent.some(i => {\n      return i !== decl && i.prop === decl.prop && i.value.length > value.length;\n    });\n\n    if (double || smaller) {\n      decl.remove();\n      return;\n    }\n\n    decl.value = value;\n  }\n  /**\n   * Parse properties list to array\n   */\n\n\n  parse(value) {\n    let ast = parser(value);\n    let result = [];\n    let param = [];\n\n    for (let node of ast.nodes) {\n      param.push(node);\n\n      if (node.type === 'div' && node.value === ',') {\n        result.push(param);\n        param = [];\n      }\n    }\n\n    result.push(param);\n    return result.filter(i => i.length > 0);\n  }\n  /**\n   * Return properties string from array\n   */\n\n\n  stringify(params) {\n    if (params.length === 0) {\n      return '';\n    }\n\n    let nodes = [];\n\n    for (let param of params) {\n      if (param[param.length - 1].type !== 'div') {\n        param.push(this.div(params));\n      }\n\n      nodes = nodes.concat(param);\n    }\n\n    if (nodes[0].type === 'div') {\n      nodes = nodes.slice(1);\n    }\n\n    if (nodes[nodes.length - 1].type === 'div') {\n      nodes = nodes.slice(0, +-2 + 1 || undefined);\n    }\n\n    return parser.stringify({\n      nodes\n    });\n  }\n  /**\n   * Return new param array with different name\n   */\n\n\n  clone(origin, name, param) {\n    let result = [];\n    let changed = false;\n\n    for (let i of param) {\n      if (!changed && i.type === 'word' && i.value === origin) {\n        result.push({\n          type: 'word',\n          value: name\n        });\n        changed = true;\n      } else {\n        result.push(i);\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Find or create separator\n   */\n\n\n  div(params) {\n    for (let param of params) {\n      for (let node of param) {\n        if (node.type === 'div' && node.value === ',') {\n          return node;\n        }\n      }\n    }\n\n    return {\n      type: 'div',\n      value: ',',\n      after: ' '\n    };\n  }\n\n  cleanOtherPrefixes(params, prefix) {\n    return params.filter(param => {\n      let current = vendor.prefix(this.findProp(param));\n      return current === '' || current === prefix;\n    });\n  }\n  /**\n   * Remove all non-webkit prefixes and unprefixed params if we have prefixed\n   */\n\n\n  cleanFromUnprefixed(params, prefix) {\n    let remove = params.map(i => this.findProp(i)).filter(i => i.slice(0, prefix.length) === prefix).map(i => this.prefixes.unprefixed(i));\n    let result = [];\n\n    for (let param of params) {\n      let prop = this.findProp(param);\n      let p = vendor.prefix(prop);\n\n      if (!remove.includes(prop) && (p === prefix || p === '')) {\n        result.push(param);\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Check property for disabled by option\n   */\n\n\n  disabled(prop, prefix) {\n    let other = ['order', 'justify-content', 'align-self', 'align-content'];\n\n    if (prop.includes('flex') || other.includes(prop)) {\n      if (this.prefixes.options.flexbox === false) {\n        return true;\n      }\n\n      if (this.prefixes.options.flexbox === 'no-2009') {\n        return prefix.includes('2009');\n      }\n    }\n\n    return undefined;\n  }\n  /**\n   * Check if transition prop is inside vendor specific rule\n   */\n\n\n  ruleVendorPrefixes(decl) {\n    let {\n      parent\n    } = decl;\n\n    if (parent.type !== 'rule') {\n      return false;\n    } else if (!parent.selector.includes(':-')) {\n      return false;\n    }\n\n    let selectors = Browsers.prefixes().filter(s => parent.selector.includes(':' + s));\n    return selectors.length > 0 ? selectors : false;\n  }\n\n}\n\nmodule.exports = Transition;","map":{"version":3,"sources":["C:/Users/alexa/Desktop/rodan-app/node_modules/autoprefixer/lib/transition.js"],"names":["list","require","parser","Browsers","vendor","Transition","constructor","prefixes","props","add","decl","result","prefix","prop","vendorPrefixes","ruleVendorPrefixes","declPrefixes","params","parse","value","names","map","i","findProp","added","some","param","prefixer","p","includes","prefixed","disabled","push","clone","concat","stringify","webkitClean","cleanFromUnprefixed","cloneBefore","operaClean","prefixValue","cleanOtherPrefixes","already","checkForWarning","test","token","entries","type","parent","isPrefixed","hasAssociatedProp","each","undefined","indexOf","values","comma","forEach","lookup","length","warn","remove","filter","double","smaller","ast","node","nodes","div","slice","origin","name","changed","after","current","unprefixed","other","options","flexbox","selector","selectors","s","module","exports"],"mappings":"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","sourcesContent":["let { list } = require('postcss')\nlet parser = require('postcss-value-parser')\n\nlet Browsers = require('./browsers')\nlet vendor = require('./vendor')\n\nclass Transition {\n  constructor(prefixes) {\n    this.props = ['transition', 'transition-property']\n    this.prefixes = prefixes\n  }\n\n  /**\n   * Process transition and add prefixes for all necessary properties\n   */\n  add(decl, result) {\n    let prefix, prop\n    let add = this.prefixes.add[decl.prop]\n    let vendorPrefixes = this.ruleVendorPrefixes(decl)\n    let declPrefixes = vendorPrefixes || (add && add.prefixes) || []\n\n    let params = this.parse(decl.value)\n    let names = params.map(i => this.findProp(i))\n    let added = []\n\n    if (names.some(i => i[0] === '-')) {\n      return\n    }\n\n    for (let param of params) {\n      prop = this.findProp(param)\n      if (prop[0] === '-') continue\n\n      let prefixer = this.prefixes.add[prop]\n      if (!prefixer || !prefixer.prefixes) continue\n\n      for (prefix of prefixer.prefixes) {\n        if (vendorPrefixes && !vendorPrefixes.some(p => prefix.includes(p))) {\n          continue\n        }\n\n        let prefixed = this.prefixes.prefixed(prop, prefix)\n        if (prefixed !== '-ms-transform' && !names.includes(prefixed)) {\n          if (!this.disabled(prop, prefix)) {\n            added.push(this.clone(prop, prefixed, param))\n          }\n        }\n      }\n    }\n\n    params = params.concat(added)\n    let value = this.stringify(params)\n\n    let webkitClean = this.stringify(\n      this.cleanFromUnprefixed(params, '-webkit-')\n    )\n    if (declPrefixes.includes('-webkit-')) {\n      this.cloneBefore(decl, `-webkit-${decl.prop}`, webkitClean)\n    }\n    this.cloneBefore(decl, decl.prop, webkitClean)\n    if (declPrefixes.includes('-o-')) {\n      let operaClean = this.stringify(this.cleanFromUnprefixed(params, '-o-'))\n      this.cloneBefore(decl, `-o-${decl.prop}`, operaClean)\n    }\n\n    for (prefix of declPrefixes) {\n      if (prefix !== '-webkit-' && prefix !== '-o-') {\n        let prefixValue = this.stringify(\n          this.cleanOtherPrefixes(params, prefix)\n        )\n        this.cloneBefore(decl, prefix + decl.prop, prefixValue)\n      }\n    }\n\n    if (value !== decl.value && !this.already(decl, decl.prop, value)) {\n      this.checkForWarning(result, decl)\n      decl.cloneBefore()\n      decl.value = value\n    }\n  }\n\n  /**\n   * Find property name\n   */\n  findProp(param) {\n    let prop = param[0].value\n    if (/^\\d/.test(prop)) {\n      for (let [i, token] of param.entries()) {\n        if (i !== 0 && token.type === 'word') {\n          return token.value\n        }\n      }\n    }\n    return prop\n  }\n\n  /**\n   * Does we already have this declaration\n   */\n  already(decl, prop, value) {\n    return decl.parent.some(i => i.prop === prop && i.value === value)\n  }\n\n  /**\n   * Add declaration if it is not exist\n   */\n  cloneBefore(decl, prop, value) {\n    if (!this.already(decl, prop, value)) {\n      decl.cloneBefore({ prop, value })\n    }\n  }\n\n  /**\n   * Show transition-property warning\n   */\n  checkForWarning(result, decl) {\n    if (decl.prop !== 'transition-property') {\n      return\n    }\n\n    let isPrefixed = false\n    let hasAssociatedProp = false\n\n    decl.parent.each(i => {\n      if (i.type !== 'decl') {\n        return undefined\n      }\n      if (i.prop.indexOf('transition-') !== 0) {\n        return undefined\n      }\n      let values = list.comma(i.value)\n      // check if current Rule's transition-property comma separated value list needs prefixes\n      if (i.prop === 'transition-property') {\n        values.forEach(value => {\n          let lookup = this.prefixes.add[value]\n          if (lookup && lookup.prefixes && lookup.prefixes.length > 0) {\n            isPrefixed = true\n          }\n        })\n        return undefined\n      }\n      // check if another transition-* prop in current Rule has comma separated value list\n      hasAssociatedProp = hasAssociatedProp || values.length > 1\n      return false\n    })\n\n    if (isPrefixed && hasAssociatedProp) {\n      decl.warn(\n        result,\n        'Replace transition-property to transition, ' +\n          'because Autoprefixer could not support ' +\n          'any cases of transition-property ' +\n          'and other transition-*'\n      )\n    }\n  }\n\n  /**\n   * Process transition and remove all unnecessary properties\n   */\n  remove(decl) {\n    let params = this.parse(decl.value)\n    params = params.filter(i => {\n      let prop = this.prefixes.remove[this.findProp(i)]\n      return !prop || !prop.remove\n    })\n    let value = this.stringify(params)\n\n    if (decl.value === value) {\n      return\n    }\n\n    if (params.length === 0) {\n      decl.remove()\n      return\n    }\n\n    let double = decl.parent.some(i => {\n      return i.prop === decl.prop && i.value === value\n    })\n    let smaller = decl.parent.some(i => {\n      return i !== decl && i.prop === decl.prop && i.value.length > value.length\n    })\n\n    if (double || smaller) {\n      decl.remove()\n      return\n    }\n\n    decl.value = value\n  }\n\n  /**\n   * Parse properties list to array\n   */\n  parse(value) {\n    let ast = parser(value)\n    let result = []\n    let param = []\n    for (let node of ast.nodes) {\n      param.push(node)\n      if (node.type === 'div' && node.value === ',') {\n        result.push(param)\n        param = []\n      }\n    }\n    result.push(param)\n    return result.filter(i => i.length > 0)\n  }\n\n  /**\n   * Return properties string from array\n   */\n  stringify(params) {\n    if (params.length === 0) {\n      return ''\n    }\n    let nodes = []\n    for (let param of params) {\n      if (param[param.length - 1].type !== 'div') {\n        param.push(this.div(params))\n      }\n      nodes = nodes.concat(param)\n    }\n    if (nodes[0].type === 'div') {\n      nodes = nodes.slice(1)\n    }\n    if (nodes[nodes.length - 1].type === 'div') {\n      nodes = nodes.slice(0, +-2 + 1 || undefined)\n    }\n    return parser.stringify({ nodes })\n  }\n\n  /**\n   * Return new param array with different name\n   */\n  clone(origin, name, param) {\n    let result = []\n    let changed = false\n    for (let i of param) {\n      if (!changed && i.type === 'word' && i.value === origin) {\n        result.push({ type: 'word', value: name })\n        changed = true\n      } else {\n        result.push(i)\n      }\n    }\n    return result\n  }\n\n  /**\n   * Find or create separator\n   */\n  div(params) {\n    for (let param of params) {\n      for (let node of param) {\n        if (node.type === 'div' && node.value === ',') {\n          return node\n        }\n      }\n    }\n    return { type: 'div', value: ',', after: ' ' }\n  }\n\n  cleanOtherPrefixes(params, prefix) {\n    return params.filter(param => {\n      let current = vendor.prefix(this.findProp(param))\n      return current === '' || current === prefix\n    })\n  }\n\n  /**\n   * Remove all non-webkit prefixes and unprefixed params if we have prefixed\n   */\n  cleanFromUnprefixed(params, prefix) {\n    let remove = params\n      .map(i => this.findProp(i))\n      .filter(i => i.slice(0, prefix.length) === prefix)\n      .map(i => this.prefixes.unprefixed(i))\n\n    let result = []\n    for (let param of params) {\n      let prop = this.findProp(param)\n      let p = vendor.prefix(prop)\n      if (!remove.includes(prop) && (p === prefix || p === '')) {\n        result.push(param)\n      }\n    }\n    return result\n  }\n\n  /**\n   * Check property for disabled by option\n   */\n  disabled(prop, prefix) {\n    let other = ['order', 'justify-content', 'align-self', 'align-content']\n    if (prop.includes('flex') || other.includes(prop)) {\n      if (this.prefixes.options.flexbox === false) {\n        return true\n      }\n\n      if (this.prefixes.options.flexbox === 'no-2009') {\n        return prefix.includes('2009')\n      }\n    }\n    return undefined\n  }\n\n  /**\n   * Check if transition prop is inside vendor specific rule\n   */\n  ruleVendorPrefixes(decl) {\n    let { parent } = decl\n\n    if (parent.type !== 'rule') {\n      return false\n    } else if (!parent.selector.includes(':-')) {\n      return false\n    }\n\n    let selectors = Browsers.prefixes().filter(s =>\n      parent.selector.includes(':' + s)\n    )\n\n    return selectors.length > 0 ? selectors : false\n  }\n}\n\nmodule.exports = Transition\n"]},"metadata":{},"sourceType":"script"}